# frozen_string_literal: true

unless FactoryBot.factories.registered?(:better_together_invitation)
  FactoryBot.define do
    factory :better_together_invitation,
            class: 'BetterTogether::Invitation',
            aliases: %i[invitation] do
      id { SecureRandom.uuid }
      lock_version { 0 }
      invitee_email { Faker::Internet.email }
      status { 'pending' }
      locale { I18n.available_locales.sample.to_s }
      valid_from { Time.zone.now }
      valid_until { valid_from + 7.days } # Optional expiry

      # Required associations for Invitation base class
      association :invitable, factory: :better_together_community
      association :inviter, factory: :better_together_person

      # Optional associations - invitee is nil for email-based invitations
      invitee { nil }

      # Optional role assignment - find the community_member role by identifier
      role { BetterTogether::Role.find_by(identifier: 'community_member') }

      # The token should be auto-generated by has_secure_token in the model

      trait :expired do
        valid_until { 1.day.ago }
      end

      trait :accepted do
        status { 'accepted' }
        accepted_at { Time.current }
      end

      trait :declined do
        status { 'declined' }
      end

      trait :with_invitee do
        association :invitee, factory: :better_together_person
        after(:build) do |invitation|
          # DB requires invitee_email to be non-null; mirror the invitee's email when present
          invitation.invitee_email = invitation.invitee.email if invitation.invitee.respond_to?(:email)
        end
      end

      trait :with_coordinator_role do
        role { BetterTogether::Role.find_by(identifier: 'community_coordinator') }
      end
    end
  end
end
